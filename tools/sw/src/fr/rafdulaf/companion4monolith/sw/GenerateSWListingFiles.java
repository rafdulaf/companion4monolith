package fr.rafdulaf.companion4monolith.sw;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class GenerateSWListingFiles
{
    private final static Set<String> EXCEPTIONS = Set.of(".git", "bin", "tools");
    
    private final static Set<String> LANGUAGES = new LinkedHashSet<>();
    
    public static void main(String[] args) throws IOException
    {
        LANGUAGES.add("en");
        LANGUAGES.add("fr");
        LANGUAGES.add("it");
        
        Path root = Path.of(args[0]);
        
        Files.list(root)
             .filter(Files::isDirectory)
             .filter(dir -> !EXCEPTIONS.contains(dir.getFileName().toString()))
             .map(Path::getFileName)
             .map(Path::toString)
             .forEach(application -> _createFiles(root, application));
    }
    
    private static void _createFiles(Path root, String application)
    {
        Map<String, Long> size = new LinkedHashMap<>();
        LANGUAGES.stream().forEach(lang -> size.put(lang, 0L));
        
        try
        {
            String rootPath = root.toString() + File.separator + application + File.separator;
            
            Set<String> files = new LinkedHashSet<>();
            files.addAll(_listFile(rootPath, root.resolve(application), size));
            
            StringBuffer sb = new StringBuffer();
            sb.append("/* This file is automatically generated, do not edit */\nconst urlsToCache = [\n");
            sb.append(files.stream().map(s -> "\t\"" + s.replace('\\', '/') + "\"").collect(Collectors.joining(",\n")));
            sb.append("\n];");
            
            Files.writeString(root.resolve(application + "/general/sw-files.js"), sb.toString());
            
            String indexContent = Files.readString(root.resolve(application).resolve("index.html"));
            indexContent = indexContent.replaceAll("const required = .*;", "const required = {" + LANGUAGES.stream().map(l -> _toString(l, size.get(l))).collect(Collectors.joining(", ")) + "};");
            Files.writeString(root.resolve(application).resolve("index.html"), indexContent);
        }
        catch (Exception e)
        {
            throw new RuntimeException(e);
        }
    }
    
    private static String _toString(String lang, Long size)
    {
        return "\"" + lang + "\": " + (long) Math.ceil(1 + size * (1024/1000.0*1024/1000.0/1000000.0));
    }

    private static Set<String> _listFile(String rootPath, Path directory, Map<String, Long> size) throws IOException
    {
        Set<String> files = new LinkedHashSet<>();
        
        final Set<String> languages = LANGUAGES;
        
        Files.walkFileTree(directory, EnumSet.of(FileVisitOption.FOLLOW_LINKS), Integer.MAX_VALUE, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException
            {
                if (Files.isRegularFile(file) // Not caching folders
                    && !file.getFileName().toString().toLowerCase().endsWith("_hd.webp")) // Not caching HS images
                {
                    long fileSize = Files.size(file);
                    boolean onlyOneLanguage = false;
                    
                    String relativePath = file.toString().substring(rootPath.length());
                    for (String lang : languages)
                    {
                        if (relativePath.contains("." + lang + ".")
                            || relativePath.contains(File.separator + lang + File.separator))
                        {
                            relativePath = relativePath.replace("." + lang + ".", ".LANGUAGE.");
                            size.put(lang, size.get(lang) + fileSize);
                            onlyOneLanguage = true;
                            break;
                        }
                    }
                    files.add(relativePath);
                    
                    if (!onlyOneLanguage)
                    {
                        languages.forEach(lang -> size.put(lang, size.get(lang) + fileSize));
                    }
                }
                return FileVisitResult.CONTINUE;
            }
        });

        return files;
    }
}
